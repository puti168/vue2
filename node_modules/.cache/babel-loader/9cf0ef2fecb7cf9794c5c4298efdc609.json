{"remainingRequest":"C:\\Users\\admin\\Desktop\\merchant-manager-web\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\admin\\Desktop\\merchant-manager-web\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\admin\\Desktop\\merchant-manager-web\\src\\utils\\encrypt\\encrypt.js","dependencies":[{"path":"C:\\Users\\admin\\Desktop\\merchant-manager-web\\src\\utils\\encrypt\\encrypt.js","mtime":1615171048073},{"path":"C:\\Users\\admin\\Desktop\\merchant-manager-web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\admin\\Desktop\\merchant-manager-web\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\admin\\Desktop\\merchant-manager-web\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.typed.uint8-array\";\nimport \"core-js/modules/es6.regexp.to-string\";\n\n/**\r\n * 数据加密算法\r\n * 原数据->JSON->GZIP压缩->Aes加密->所以无需在Base64加密\r\n *\r\n * 签名生成\r\n * sign = （加密之后的string数据 + nonce + timestamp）-> HmacSHA1加密 -> Base64加密\r\n */\nimport CryptoJS from 'crypto-js';\nimport HmacSHA1 from 'crypto-js/hmac-sha1';\n\nvar pako = require('pako');\n\nvar dataHandle = function dataHandle() {}; // 当前的默认密钥\n\n\nvar defaultKey = '0123456789ABCDEF';\n/**\r\n * 数据加密\r\n * param { data } 明文JSON字符串\r\n * param { key } 当前加密算法通用密钥\r\n */\n\ndataHandle.encrypt = function (data) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultKey;\n\n  if (typeof data !== 'string') {\n    data = JSON.stringify(data);\n  } // 将秘钥转换成Utf8字节数组\n\n\n  var commonKey = CryptoJS.enc.Utf8.parse(key); // zip压缩数据\n\n  var zipData = zip(data); // aes加密 直接输出Base64加密的数据 所以无需在Base64加密\n\n  var aesEncryptData = aesEncrypt(zipData, commonKey);\n  return aesEncryptData;\n};\n/**\r\n * 生成签名\r\n * param { data } 加密后数据\r\n * param { nonce } long整型 随机数\r\n * param { timestamp } 当前时间戳\r\n * param { key } 生成签名的密钥 当前应该是和加密的密钥是同一个\r\n */\n\n\ndataHandle.createSign = function (data, nonce, timestamp, key) {\n  // sign 字符串\n  var sign = data + nonce + timestamp; // hmacSHA1加密 -- 这里不需要做任何转吗，CryptoJS底层默认会转UTF-8\n\n  var sha1Data = HmacSHA1(sign, key); // base64 加密数据\n\n  var base64Data = CryptoJS.enc.Base64.stringify(sha1Data);\n  return base64Data;\n};\n/**\r\n * 创建long整型随机数\r\n * Java端说 只需要0-MaxValue就可以了\r\n */\n\n\ndataHandle.createNonce = function () {\n  return Math.round(Math.random() * Math.pow(2, 63));\n};\n/**\r\n * 创建时间戳\r\n * TODO 再次之前应该向服务器拉取服务器时间，之后校验本地时间\r\n */\n\n\ndataHandle.createTimestamp = function () {\n  return new Date().getTime();\n};\n/**\r\n * 数据解密\r\n * param { data } 加密数据\r\n * param { key } 当前加密算法通用密钥\r\n */\n\n\ndataHandle.decrypt = function (data, key) {\n  // 将秘钥转换成Utf8字节数组\n  var commonKey = CryptoJS.enc.Utf8.parse(key); // aes解密\n\n  var aesData = aesDecrypt(data, commonKey); // GZIP解密\n\n  var gzipData = unzip(aesData);\n  return gzipData;\n}; // gzip压缩 gzip 传入的参数只要不是string都是会直接崩溃的\n\n\nfunction zip(str) {\n  // string 输出字符串\n  // [object ArrayBuffer] 输出Unit8Array\n  var binary = pako.gzip(str, {\n    to: '[object ArrayBuffer]'\n  });\n  return binary;\n} // gzip解压\n\n\nfunction unzip(key) {\n  // GZIP解压\n  var data = pako.inflate(key); // 16进制字节流 转wordArray\n\n  var wordArray = typeArrayToWordArray(data); // wordArray 转UTF-8\n\n  var str = CryptoJS.enc.Utf8.stringify(wordArray);\n  return str;\n} // aes加密\n\n\nfunction aesEncrypt(zipData, key) {\n  // Uint8Array的数据转成WordArray的数据\n  if (typeof zipData !== 'string') {\n    zipData = typeArrayToWordArray(zipData);\n  } // 这里key一定要转UTF-8 否则会发现每次Aes结果都不一样 没找到原因\n  // 这里的加密模式是CBC 虽然他们文档写的ECB 但是Java后端全都是CBC的\n  // padding 数据对齐方式后端是cs5 前端此时选择cs7结果都是一样的，这个一定是没问题的，另一个原因是前端只有cs7，说是cs7和cs5几乎没区别。\n\n\n  var encrypt = CryptoJS.AES.encrypt(zipData, key, {\n    iv: key,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  });\n  return encrypt.toString();\n} // aes解密\n\n\nfunction aesDecrypt(data, key) {\n  var decrypt = CryptoJS.AES.decrypt(data, key, {\n    iv: key,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  }); // 这里转成Unit8Array方便Gzip解压\n\n  var bytesArray = wordToBytesArray(decrypt);\n  return bytesArray;\n} // typedArrayToWordArray 字节数组转word数组\n\n\nfunction typeArrayToWordArray(u8arr) {\n  // Shortcut\n  var len = u8arr.length; // Convert\n\n  var words = [];\n\n  for (var i = 0; i < len; i++) {\n    words[i >>> 2] |= (u8arr[i] & 0xff) << 24 - i % 4 * 8;\n  }\n\n  return CryptoJS.lib.WordArray.create(words, len);\n} // wordArray 转 字节数组\n\n\nvar wordToBytesArray = function wordToBytesArray(wordArray) {\n  // Shortcuts\n  var words = wordArray.words;\n  var sigBytes = wordArray.sigBytes; // Convert\n\n  var u8 = new Uint8Array(sigBytes);\n\n  for (var i = 0; i < sigBytes; i++) {\n    var byte = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n    u8[i] = byte;\n  }\n\n  return u8;\n};\n\nexport default dataHandle;",null]}